<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RSS Reader ‚Äì Fixed Translation Edition</title>

<style>
  body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f5f5f5; }
  .container { max-width: 700px; margin: auto; padding: 12px; }

  .nav-bar { display: flex; justify-content: space-between; align-items: center;
             margin-bottom: 12px; padding: 4px 0; border-bottom: 1px solid #ddd; }
  .nav-bar a { text-decoration: none; color: #0078ff; font-size: 14px; font-weight: bold; }
  #syncStatus { font-size: 10px; color: #888; margin-left: 8px; }

  mark.custom-highlight { background-color: #ffeb3b; color: #000; padding: 0 1px; border-radius: 2px; }

  select { width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #ccc;
           font-size: 14px; background: white; margin-bottom: 10px; }

  .carousel { display: flex; overflow-x: scroll; scroll-snap-type: x mandatory; gap: 10px;
              padding: 10px 0; -webkit-overflow-scrolling: touch; }
  .slide { min-width: 75%; background: white; padding: 6px; border-radius: 10px;
           scroll-snap-align: center; box-shadow: 0 1px 4px rgba(0,0,0,0.15);
           height: 120px; display: flex; align-items: center; justify-content: center;
           cursor: pointer; }
  .slide img { width: 100%; height: 100%; object-fit: cover; border-radius: 8px; }

  .article { background: white; padding: 20px; margin-top: 12px; border-radius: 12px;
             line-height: 1.25; font-size: 15px; opacity: 0; animation: fadeIn 0.4s forwards; }
  .article h2 { font-size: 18px; margin-top: 0; line-height: 1.2; margin-bottom: 20px; }

  .translation-group {
    margin-bottom: 12px;
    border-left: 2px solid #e0e0e0;
    padding-left: 8px;
  }

  .translation-original {
    display: block;
    margin-bottom: 2px;
    line-height: 1.4;
  }

  .translation-line {
    display: block;
    color: #003399;
    font-style: italic;
    margin-left: 10px;
    margin-bottom: 8px;
    line-height: 1.4;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 3px;
    min-height: 24px;
  }

  .translation-line.loading {
    color: #999;
    font-style: normal;
  }

  .translation-line.error {
    color: #cc0000;
    font-style: normal;
  }

  .translation-line:hover:not(.loading):not(.error) {
    background-color: #f0f0f0;
  }

  .translation-line.active-line {
    background-color: #e3f2fd;
    text-decoration: underline;
    text-decoration-thickness: 2px;
  }

  /* Grammatica markering */
  .translation-line strong {
    font-weight: bold !important;
  }

  .translation-line .noun {
    color: #8b0000 !important;
  }

  /* Debug info */
  .debug-panel {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    padding: 10px;
    margin: 10px 0;
    font-size: 12px;
    display: none;
  }

  .debug-toggle {
    font-size: 11px;
    color: #666;
    cursor: pointer;
    user-select: none;
    margin-left: 10px;
  }

  .toggle-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }

  .audio-controls {
    display: none;
    gap: 12px;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }

  .audio-btn {
    flex: 1;
    padding: 12px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    background: #0078ff;
    color: white;
    font-weight: bold;
    text-align: center;
  }

  .audio-btn.stop { background: #cc0000; }
  .audio-btn.pause { background: #ffaa00; }

  #progressBar {
    font-size: 13px;
    color: #444;
    margin-bottom: 8px;
    display: none;
  }

  @keyframes fadeIn { to { opacity: 1; } }
</style>
</head>
<body>

<div class="container">

  <div class="nav-bar">
    <div>
      <strong>Reader</strong><span id="syncStatus"></span>
      <span class="debug-toggle" onclick="toggleDebug()">üîç Debug</span>
    </div>
    <a href="woorden.html">Instellingen ‚öôÔ∏è</a>
  </div>

  <!-- DEBUG PANEL -->
  <div id="debugPanel" class="debug-panel">
    <strong>Debug Info:</strong>
    <div id="debugInfo">Geen activiteit</div>
    <button onclick="testTranslation()" style="margin-top: 5px; padding: 5px 10px; font-size: 11px;">
      Test Translation API
    </button>
  </div>

  <div class="toggle-row">
    <input type="checkbox" id="toggleTranslate" checked>
    <label for="toggleTranslate">Vertaling inschakelen</label>
  </div>

  <!-- GRAMMATICA MARKERING TOGGLE -->
  <div class="toggle-row">
    <input type="checkbox" id="toggleGrammar" checked>
    <label for="toggleGrammar">Werkwoorden (vet) & zelfstandige naamwoorden (rood) markeren</label>
  </div>

  <!-- AUDIO BUTTONS -->
  <div id="audioControls" class="audio-controls">
    <button class="audio-btn" onclick="speakTranslation()">‚ñ∂Ô∏è Afspelen</button>
    <button class="audio-btn pause" onclick="pauseSpeaking()">‚è∏Ô∏è Pauze</button>
    <button class="audio-btn stop" onclick="stopSpeaking()">‚èπÔ∏è Stop</button>
  </div>

  <div id="progressBar"></div>

  <select id="feedSelect" onchange="loadSelectedFeed()"></select>
  <div id="carousel" class="carousel"></div>
  <div id="article" class="article"></div>

</div>

<script>
let items = [];
let currentIndex = 0;
let currentArticleData = null;

/* ========= DEBUG FUNCTIONS ========= */

function updateDebugInfo(message) {
  const debugInfo = document.getElementById('debugInfo');
  const now = new Date().toLocaleTimeString();
  debugInfo.innerHTML = `[${now}] ${message}<br>` + debugInfo.innerHTML;
}

function toggleDebug() {
  const panel = document.getElementById('debugPanel');
  panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}

async function testTranslation() {
  console.log('=== TESTING TRANSLATION API ===');
  updateDebugInfo('Starting translation test...');
  
  const testSentences = [
    "Hello, how are you?",
    "The weather is beautiful today.",
    "I am learning Portuguese."
  ];
  
  try {
    const url = `/api/translate?sentences=${encodeURIComponent(JSON.stringify(testSentences))}&target=pt-BR`;
    updateDebugInfo(`Fetching: ${url.substring(0, 80)}...`);
    
    const response = await fetch(url);
    updateDebugInfo(`Response status: ${response.status}`);
    
    const data = await response.json();
    console.log('API Response:', data);
    updateDebugInfo(`Got response with ${data.translations ? data.translations.length : 0} translations`);
    
    if (data.translations) {
      data.translations.forEach((trans, i) => {
        const isPortuguese = validatePortugueseTranslation(trans);
        console.log(`Translation ${i + 1}: ${isPortuguese ? '‚úÖ Portuguese' : '‚ùå NOT Portuguese'}`);
        console.log(`  Original: "${testSentences[i]}"`);
        console.log(`  Translation: "${trans}"`);
        
        updateDebugInfo(`Trans ${i + 1}: ${isPortuguese ? '‚úÖ' : '‚ùå'} "${trans.substring(0, 50)}..."`);
      });
    }
    
  } catch (error) {
    console.error('Test failed:', error);
    updateDebugInfo(`Error: ${error.message}`);
  }
}

/* ========= TRANSLATION VALIDATION ========= */

function validatePortugueseTranslation(text) {
  if (!text || typeof text !== 'string') return false;
  
  // Remove HTML tags for validation
  const cleanText = text.replace(/<[^>]*>/g, '');
  if (cleanText.length === 0) return false;
  
  // Check for Portuguese-specific characters
  const portugueseChars = /[√°√†√¢√£√©√®√™√≠√¨√Æ√≥√≤√¥√µ√∫√π√ª√ß√±]/i;
  const hasPortugueseChars = portugueseChars.test(cleanText);
  
  // Common Portuguese words that are unlikely in Dutch
  const portugueseWords = [
    '√©', 'est√°', 'est√£o', 'foi', 'foram', 'tem', 't√™m', 'h√°',
    'que', 'como', 'para', 'com', 'n√£o', 'sim', 'ou', 'e',
    'o', 'a', 'os', 'as', 'um', 'uma', 'uns', 'umas',
    'do', 'da', 'dos', 'das', 'no', 'na', 'nos', 'nas',
    'meu', 'minha', 'teu', 'tua', 'seu', 'sua', 'nosso', 'nossa',
    'voc√™', 'voc√™s', 'n√≥s', 'eles', 'elas'
  ];
  
  const lowerText = cleanText.toLowerCase();
  
  // Check for Portuguese words
  let portugueseWordCount = 0;
  portugueseWords.forEach(word => {
    if (new RegExp(`\\b${word}\\b`).test(lowerText)) {
      portugueseWordCount++;
    }
  });
  
  // Check for Dutch words that shouldn't be in Portuguese
  const dutchWords = ['de', 'het', 'een', 'en', 'van', 'ik', 'je', 'dat', 'niet', 'is', 'wat'];
  let dutchWordCount = 0;
  dutchWords.forEach(word => {
    if (new RegExp(`\\b${word}\\b`).test(lowerText)) {
      dutchWordCount++;
    }
  });
  
  // Debug info
  console.log(`Validation: "${cleanText.substring(0, 50)}..."`);
  console.log(`  Portuguese chars: ${hasPortugueseChars}`);
  console.log(`  Portuguese words: ${portugueseWordCount}`);
  console.log(`  Dutch words: ${dutchWordCount}`);
  
  // Validation logic
  if (hasPortugueseChars) return true;
  if (portugueseWordCount > 1) return true;
  if (dutchWordCount > 2 && !hasPortugueseChars) return false;
  
  return false; // Default to not Portuguese
}

/* ========= OPTIMIZED BATCH TRANSLATION ========= */

async function translateSentencesBatch(sentences, targetLang = "pt-BR") {
  if (sentences.length === 0) return [];
  
  updateDebugInfo(`Translating batch of ${sentences.length} sentences`);
  console.log(`[Translate] Batch: ${sentences.length} sentences`);
  
  try {
    // Use the efficient batch API
    const url = `/api/translate?sentences=${encodeURIComponent(JSON.stringify(sentences))}&target=${targetLang}`;
    
    updateDebugInfo(`Calling API...`);
    console.log(`[Translate] API URL: ${url.substring(0, 100)}...`);
    
    const response = await fetch(url);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[Translate] API error ${response.status}:`, errorText);
      updateDebugInfo(`API error ${response.status}`);
      throw new Error(`API error: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('[Translate] API response:', data);
    updateDebugInfo(`Got API response`);
    
    let translations = [];
    if (data.translations && Array.isArray(data.translations)) {
      translations = data.translations;
    } else if (Array.isArray(data)) {
      translations = data;
    } else {
      console.warn('[Translate] Unexpected response format:', data);
      updateDebugInfo('Unexpected response format');
      // Fallback with error indication
      return sentences.map(s => `<span class="error">[TRANSLATION ERROR] ${s}</span>`);
    }
    
    // VALIDATE EACH TRANSLATION
    const validatedTranslations = [];
    let validCount = 0;
    
    for (let i = 0; i < translations.length; i++) {
      const translation = translations[i];
      const original = sentences[i];
      
      const isPortuguese = validatePortugueseTranslation(translation);
      const isSameAsOriginal = translation === original;
      
      console.log(`[Translate] Sentence ${i + 1}:`);
      console.log(`  Original: "${original}"`);
      console.log(`  Translation: "${translation}"`);
      console.log(`  Is Portuguese: ${isPortuguese}`);
      console.log(`  Same as original: ${isSameAsOriginal}`);
      
      if (!isPortuguese || isSameAsOriginal) {
        // Translation failed
        console.warn(`[Translate] Translation ${i + 1} failed validation`);
        validatedTranslations.push(`<span class="error">[VERTALING MISLUKT] ${original}</span>`);
        updateDebugInfo(`Translation ${i + 1} failed validation`);
      } else {
        validatedTranslations.push(translation);
        validCount++;
      }
    }
    
    updateDebugInfo(`Validated: ${validCount}/${sentences.length} successful`);
    console.log(`[Translate] Valid translations: ${validCount}/${sentences.length}`);
    
    return validatedTranslations;
    
  } catch (error) {
    console.error('[Translate] Error:', error);
    updateDebugInfo(`Translation error: ${error.message}`);
    
    // Fallback with error indication
    return sentences.map(s => `<span class="error">[API ERROR] ${s}</span>`);
  }
}

/* ========= AUDIO ENGINE ========= */

let isSpeaking = false;
let isPaused = false;
let currentUtterance = null;
let currentLineIndex = 0;
let lines = [];

function getBrazilianVoice() {
  const voices = speechSynthesis.getVoices();
  return (
    voices.find(v => v.lang === "pt-BR") ||
    voices.find(v => v.lang.startsWith("pt")) ||
    voices[0]
  );
}

function updateProgress() {
  const bar = document.getElementById("progressBar");
  if (!isSpeaking) {
    bar.style.display = "none";
    return;
  }
  bar.style.display = "block";
  bar.innerText = `Zin ${currentLineIndex + 1} van ${lines.length}`;
}

function highlightActiveLine() {
  document.querySelectorAll(".translation-line").forEach(el => {
    el.classList.remove("active-line");
  });
  const active = document.querySelector(`.translation-line[data-index="${currentLineIndex}"]`);
  if (active) active.classList.add("active-line");
}

function speakTranslation() {
  if (isSpeaking) return;

  const article = document.getElementById("article");
  lines = [...article.querySelectorAll(".translation-line:not(.loading):not(.error)")].map(el => {
    const temp = document.createElement('div');
    temp.innerHTML = el.innerHTML;
    temp.querySelectorAll('strong, .noun, .error').forEach(tag => {
      tag.replaceWith(tag.textContent);
    });
    return temp.textContent.trim();
  }).filter(text => text.length > 0 && !text.startsWith('[VERTALING MISLUKT]') && !text.startsWith('[API ERROR]'));

  if (lines.length === 0) {
    alert("Geen geldige vertaalde zinnen om voor te lezen");
    return;
  }

  const voice = getBrazilianVoice();
  isSpeaking = true;
  isPaused = false;
  currentLineIndex = 0;

  function speakNext() {
    if (!isSpeaking || currentLineIndex >= lines.length) {
      isSpeaking = false;
      updateProgress();
      highlightActiveLine();
      return;
    }

    highlightActiveLine();
    updateProgress();

    currentUtterance = new SpeechSynthesisUtterance(lines[currentLineIndex]);
    currentUtterance.voice = voice;
    currentUtterance.rate = 1.0;
    currentUtterance.pitch = 1.0;

    currentUtterance.onend = () => {
      if (!isPaused) {
        currentLineIndex++;
        speakNext();
      }
    };

    speechSynthesis.speak(currentUtterance);
  }

  speakNext();
}

function pauseSpeaking() {
  if (!isSpeaking) return;
  if (!isPaused) {
    speechSynthesis.pause();
    isPaused = true;
  } else {
    speechSynthesis.resume();
    isPaused = false;
  }
}

function stopSpeaking() {
  isSpeaking = false;
  isPaused = false;
  speechSynthesis.cancel();
  updateProgress();
  document.querySelectorAll(".translation-line").forEach(el => el.classList.remove("active-line"));
}

function playSingleLine(i) {
  stopSpeaking();
  const voice = getBrazilianVoice();
  const el = document.querySelector(`.translation-line[data-index="${i}"]`);
  if (!el || el.classList.contains('loading') || el.classList.contains('error')) return;

  document.querySelectorAll(".translation-line").forEach(x => x.classList.remove("active-line"));
  el.classList.add("active-line");

  const temp = document.createElement('div');
  temp.innerHTML = el.innerHTML;
  temp.querySelectorAll('strong, .noun').forEach(tag => {
    tag.replaceWith(tag.textContent);
  });
  const text = temp.textContent.trim();

  const u = new SpeechSynthesisUtterance(text);
  u.voice = voice;
  u.rate = 1.0;
  u.pitch = 1.0;

  u.onend = () => el.classList.remove("active-line");

  speechSynthesis.speak(u);
}

/* ========= ARTICLE PROCESSING ========= */

function splitIntoSentences(text) {
  return text
    .replace(/\s+/g, " ")
    .trim()
    .split(/(?<![A-Z][a-z]\.)(?<![A-Z][a-z][a-z]\.)(?<![Mm]r\.)(?<![Mm]rs\.)(?<![Dd]r\.)(?<![Pp]rof\.)(?<![Ss]r\.)(?<![Jj]r\.)(?<![Vv]s\.)(?<![Ee]tc\.)(?<![Ee]g\.)(?<![Ii]e\.)(?<=[.!?])\s+/)
    .filter(s => s.trim().length > 0);
}

async function translateArticleContent(html, targetLang = "pt-BR") {
  const temp = document.createElement("div");
  temp.innerHTML = html;
  
  const text = temp.textContent || temp.innerText || "";
  const sentences = splitIntoSentences(text);
  
  if (sentences.length === 0) {
    return '<p>Geen tekst gevonden in artikel.</p>';
  }
  
  updateDebugInfo(`Processing article with ${sentences.length} sentences`);
  
  // Process in optimal batches
  const BATCH_SIZE = 10;
  const allTranslations = [];
  
  for (let i = 0; i < sentences.length; i += BATCH_SIZE) {
    const batch = sentences.slice(i, Math.min(i + BATCH_SIZE, sentences.length));
    updateDebugInfo(`Translating batch ${Math.floor(i/BATCH_SIZE) + 1} (${batch.length} sentences)`);
    
    const translations = await translateSentencesBatch(batch, targetLang);
    allTranslations.push(...translations);
  }
  
  // Build the HTML
  let outputHTML = '';
  const grammarEnabled = document.getElementById("toggleGrammar").checked;
  
  sentences.forEach((sentence, index) => {
    let translationHTML = allTranslations[index] || "";
    
    // Check if translation failed
    const isError = translationHTML.includes('class="error"') || 
                    translationHTML.includes('[VERTALING MISLUKT]') ||
                    translationHTML.includes('[API ERROR]');
    
    if (isError) {
      outputHTML += `
        <div class="translation-group">
          <span class="translation-original">${sentence}</span>
          <br>
          <span class="translation-line error" data-index="${index}">
            ${translationHTML}
          </span>
        </div>
      `;
    } else {
      // Apply grammar markup if enabled
      if (grammarEnabled && translationHTML) {
        translationHTML = translationHTML
          .replace(/<span style="color:darkred">/g, '<span class="noun">')
          .replace(/<span style="color: darkred">/g, '<span class="noun">');
      } else if (!grammarEnabled && translationHTML) {
        translationHTML = translationHTML
          .replace(/<strong>/g, '')
          .replace(/<\/strong>/g, '')
          .replace(/<span[^>]*>/g, '')
          .replace(/<\/span>/g, '');
      }
      
      outputHTML += `
        <div class="translation-group">
          <span class="translation-original">${sentence}</span>
          <br>
          <span class="translation-line" data-index="${index}" onclick="playSingleLine(${index})">
            ${translationHTML || '<em>Geen vertaling beschikbaar</em>'}
          </span>
        </div>
      `;
    }
  });
  
  updateDebugInfo(`Article translation completed`);
  return outputHTML;
}

/* ========= CLOUD SYNC + RSS ========= */

async function fetchCloudData(url) {
  if (!url) return [];
  try {
    const resp = await fetch(url);
    const text = await resp.text();
    return text.split(/[\r\n]+/).map(r => r.replace(/^"|"$/g, "").trim()).filter(r => r);
  } catch {
    return null;
  }
}

async function startSync() {
  const statusEl = document.getElementById("syncStatus");
  statusEl.textContent = "(Syncing...)";

  const wordUrl = localStorage.getItem("syncSheetUrl");
  const feedUrl = localStorage.getItem("syncFeedUrl");

  const [words, feeds] = await Promise.all([
    fetchCloudData(wordUrl),
    fetchCloudData(feedUrl)
  ]);

  if (words) localStorage.setItem("highlightWords", JSON.stringify(words));
  if (feeds) localStorage.setItem("rssFeeds", JSON.stringify(feeds));

  statusEl.textContent = words && feeds ? "(Cloud OK)" : "(Offline)";
}

function applyHighlights(html, words) {
  if (!words || words.length === 0) return html;
  const pattern = [...words]
    .sort((a, b) => b.length - a.length)
    .map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
    .join("|");
  const regex = new RegExp(`\\b(${pattern})\b(?=[^>]*<)`, "gi");
  return html.replace(regex, m => `<mark class="custom-highlight">${m}</mark>`);
}

function loadSavedFeeds() {
  const select = document.getElementById("feedSelect");
  const feeds = JSON.parse(localStorage.getItem("rssFeeds") || "[]");
  select.innerHTML = feeds.map(f => `<option value="${f}">${f}</option>`).join("");
  if (feeds.length > 0) loadFeed(feeds[0]);
}

async function loadFeed(url) {
  const carousel = document.getElementById("carousel");
  carousel.innerHTML = "Laden...";
  try {
    const resp = await fetch(
      `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(url)}`
    );
    const data = await resp.json();
    items = data.items || [];
    
    carousel.innerHTML = items
      .map((item, idx) => `<div class="slide" data-index="${idx}"><img src="${
        item.thumbnail ||
        (item.enclosure && item.enclosure.link) ||
        "https://via.placeholder.com/150"
      }"></div>`)
      .join("");
    
    setTimeout(() => {
      if (carousel.scrollLeft === 0) {
        loadArticle(0);
      }
    }, 100);
    
  } catch {
    carousel.innerHTML = "Fout bij laden feed.";
  }
}

function loadSelectedFeed() {
  loadFeed(document.getElementById("feedSelect").value);
}

async function loadArticle(index) {
  stopSpeaking();

  const container = document.getElementById("article");
  container.style.opacity = 0;
  container.innerHTML = "Artikel laden...";
  currentIndex = index;

  try {
    const link = items[index]?.link;
    if (!link) return;

    const resp = await fetch(`/api/article?url=${encodeURIComponent(link)}`);
    const data = await resp.json();
    const words = JSON.parse(localStorage.getItem("highlightWords") || "[]");

    let html = data.content;
    const title = data.title || "";

    const translateOn = document.getElementById("toggleTranslate").checked;

    document.getElementById("audioControls").style.display =
      translateOn ? "flex" : "none";

    if (translateOn) {
      html = await translateArticleContent(html, "pt-BR");
    } else {
      // Just show original content without translation
      const sentences = splitIntoSentences(html.replace(/<[^>]*>/g, ' '));
      
      html = sentences.map(sentence => `
        <div class="translation-group">
          <span class="translation-original">${sentence}</span>
          <br>
          <span class="translation-line"><em>Vertaling uitgeschakeld</em></span>
        </div>
      `).join('');
    }

    container.innerHTML = `
      <h2>${applyHighlights(title, words)}</h2>
      ${html}
    `;

    requestAnimationFrame(() => container.style.opacity = 1);

  } catch (error) {
    console.error("Fout bij laden artikel:", error);
    container.innerHTML = "Fout bij laden van artikel.";
    updateDebugInfo(`Error loading article: ${error.message}`);
  }
}

/* ========= SWIPE ========= */

let carouselScrollTimeout;

document.getElementById("carousel").onscroll = () => {
  clearTimeout(carouselScrollTimeout);
  carouselScrollTimeout = setTimeout(() => {
    const slide = document.querySelector(".slide");
    if (!slide) return;
    const slideWidth = slide.offsetWidth + 10;
    const index = Math.round(document.getElementById("carousel").scrollLeft / slideWidth);
    if (index !== currentIndex && items[index]) {
      loadArticle(index);
    }
  }, 50);
};

// Directe klik op slides
document.getElementById("carousel").addEventListener("click", (e) => {
  const slide = e.target.closest(".slide");
  if (slide) {
    const index = parseInt(slide.dataset.index);
    if (!isNaN(index) && index !== currentIndex && items[index]) {
      slide.scrollIntoView({ behavior: 'smooth', inline: 'center' });
      loadArticle(index);
    }
  }
});

/* ========= TOGGLE EVENT LISTENERS ========= */

document.getElementById("toggleGrammar").addEventListener("change", function() {
  if (currentArticleData) {
    loadArticle(currentIndex);
  }
});

document.getElementById("toggleTranslate").addEventListener("change", function() {
  if (items.length > 0) {
    loadArticle(currentIndex);
  }
});

/* ========= INIT ========= */

async function init() {
  console.log("Reader initialiseren...");
  updateDebugInfo("Initializing reader...");
  await startSync();
  loadSavedFeeds();

  if (typeof speechSynthesis !== "undefined") {
    speechSynthesis.onvoiceschanged = () => {
      console.log("Spraakstemmen geladen:", speechSynthesis.getVoices().length);
    };
  }
}

init();

</script>
</body>
</html>
