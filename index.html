<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RSS Reader – High Performance Edition</title>

<style>
  body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f5f5f5; }
  .container { max-width: 700px; margin: auto; padding: 12px; }

  .nav-bar { display: flex; justify-content: space-between; align-items: center;
             margin-bottom: 12px; padding: 4px 0; border-bottom: 1px solid #ddd; }
  .nav-bar a { text-decoration: none; color: #0078ff; font-size: 14px; font-weight: bold; }
  #syncStatus { font-size: 10px; color: #888; margin-left: 8px; }

  mark.custom-highlight { background-color: #ffeb3b; color: #000; padding: 0 1px; border-radius: 2px; }

  select { width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #ccc;
           font-size: 14px; background: white; margin-bottom: 10px; }

  .carousel { display: flex; overflow-x: scroll; scroll-snap-type: x mandatory; gap: 10px;
              padding: 10px 0; -webkit-overflow-scrolling: touch; }
  .slide { min-width: 75%; background: white; padding: 6px; border-radius: 10px;
           scroll-snap-align: center; box-shadow: 0 1px 4px rgba(0,0,0,0.15);
           height: 120px; display: flex; align-items: center; justify-content: center;
           cursor: pointer; }
  .slide img { width: 100%; height: 100%; object-fit: cover; border-radius: 8px; }

  .article { background: white; padding: 20px; margin-top: 12px; border-radius: 12px;
             line-height: 1.25; font-size: 15px; opacity: 0; animation: fadeIn 0.4s forwards; }
  .article h2 { font-size: 18px; margin-top: 0; line-height: 1.2; margin-bottom: 20px; }

  .translation-group {
    margin-bottom: 12px;
    border-left: 2px solid #e0e0e0;
    padding-left: 8px;
    min-height: 60px; /* Zorg voor consistentie tijdens laden */
  }

  .translation-original {
    display: block;
    margin-bottom: 2px;
    line-height: 1.4;
  }

  .translation-line {
    display: block;
    color: #003399;
    font-style: italic;
    margin-left: 10px;
    margin-bottom: 8px;
    line-height: 1.4;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 3px;
    transition: background-color 0.2s;
  }

  .translation-line.loading {
    color: #999;
    font-style: normal;
  }

  .translation-line:hover:not(.loading) {
    background-color: #f0f0f0;
  }

  .translation-line.active-line {
    background-color: #e3f2fd;
    text-decoration: underline;
    text-decoration-thickness: 2px;
  }

  /* Grammatica markering */
  .translation-line strong {
    font-weight: bold !important;
  }

  .translation-line .noun {
    color: #8b0000 !important;
  }

  /* Paginering controls */
  .pagination-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #e0e0e0;
  }

  .pagination-btn {
    padding: 10px 20px;
    background: #0078ff;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.2s;
  }

  .pagination-btn:hover:not(:disabled) {
    background: #0056cc;
  }

  .pagination-btn:disabled {
    background: #cccccc;
    cursor: not-allowed;
  }

  .pagination-info {
    font-size: 14px;
    color: #666;
    font-weight: bold;
    text-align: center;
    min-width: 200px;
  }

  .toggle-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }

  .audio-controls {
    display: none;
    gap: 12px;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }

  .audio-btn {
    flex: 1;
    padding: 12px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    background: #0078ff;
    color: white;
    font-weight: bold;
    text-align: center;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  .audio-btn:hover {
    background: #0056cc;
  }

  .audio-btn.stop { background: #cc0000; }
  .audio-btn.stop:hover { background: #990000; }
  .audio-btn.pause { background: #ffaa00; }
  .audio-btn.pause:hover { background: #cc8800; }

  #progressBar {
    font-size: 13px;
    color: #444;
    margin-bottom: 8px;
    display: none;
  }

  /* Laadindicator */
  .loading-indicator {
    display: none;
    text-align: center;
    padding: 15px;
    margin: 10px 0;
    background: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    color: #666;
    font-style: italic;
    font-size: 14px;
  }

  .loading-indicator .progress {
    display: inline-block;
    font-weight: bold;
    color: #0078ff;
    min-width: 40px;
  }

  .skeleton-loader {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    border-radius: 4px;
    height: 20px;
    margin: 5px 0;
  }

  @keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }

  @keyframes fadeIn { to { opacity: 1; } }

  /* Performance warning */
  .performance-warning {
    display: none;
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 6px;
    padding: 10px;
    margin: 10px 0;
    font-size: 13px;
    color: #856404;
  }
</style>
</head>
<body>

<div class="container">

  <div class="nav-bar">
    <div><strong>Reader</strong><span id="syncStatus"></span></div>
    <a href="woorden.html">Instellingen ⚙️</a>
  </div>

  <!-- PERFORMANCE WARNING -->
  <div id="performanceWarning" class="performance-warning">
    ⚡ <strong>Performance modus:</strong> Vertalingen laden per pagina voor snellere weergave.
  </div>

  <div class="toggle-row">
    <input type="checkbox" id="toggleTranslate" checked>
    <label for="toggleTranslate">Vertaling inschakelen</label>
  </div>

  <!-- GRAMMATICA MARKERING TOGGLE -->
  <div class="toggle-row">
    <input type="checkbox" id="toggleGrammar" checked>
    <label for="toggleGrammar">Werkwoorden (vet) & zelfstandige naamwoorden (rood) markeren</label>
  </div>

  <!-- LAADINDICATOR -->
  <div id="loadingIndicator" class="loading-indicator">
    <div>Vertaling laden: <span class="progress" id="loadingProgress">0%</span></div>
    <div style="font-size:12px; color:#888; margin-top:5px;" id="loadingDetails"></div>
  </div>

  <!-- NAVIGATION BUTTONS -->
  <div id="audioNav" class="audio-controls">
    <button class="audio-btn" onclick="prevLine()">⏮️ Vorige zin</button>
    <button class="audio-btn" onclick="nextLine()">⏭️ Volgende zin</button>
  </div>

  <!-- SPEED SLIDER -->
  <div id="speedControl" style="display:none; margin-bottom:12px;">
    <label for="speedSlider" style="font-size:13px; color:#444;">Spreeksnelheid</label>
    <input type="range" id="speedSlider" min="0.5" max="1.5" step="0.1" value="1.0" style="width:100%;">
  </div>

  <!-- AUDIO BUTTONS -->
  <div id="audioControls" class="audio-controls">
    <button class="audio-btn" onclick="speakTranslation()">▶️ Afspelen alle zinnen</button>
    <button class="audio-btn pause" onclick="pauseSpeaking()">⏸️ Pauze</button>
    <button class="audio-btn stop" onclick="stopSpeaking()">⏹️ Stop</button>
  </div>

  <div id="progressBar"></div>

  <select id="feedSelect" onchange="loadSelectedFeed()"></select>
  <div id="carousel" class="carousel"></div>
  
  <!-- ARTICLE CONTAINER MET PAGINERING -->
  <div id="article" class="article">
    <!-- Artikel wordt hier ingeladen met paginering -->
  </div>

</div>

<script>
let items = [];
let currentIndex = 0;

/* ========= PAGINERING GLOBALE VARIABELEN ========= */
let currentArticleData = null;
let currentPage = 0;
const SENTENCES_PER_PAGE = 8; // Verminderd van 10 naar 8 voor snellere vertaling
let totalPages = 0;

/* ========= PERFORMANCE METRICS ========= */
let performanceMetrics = {
  pageLoadStart: 0,
  translationStart: 0,
  translationEnd: 0
};

/* ========= AUDIO ENGINE ========= */

let isSpeaking = false;
let isPaused = false;
let currentUtterance = null;
let currentLineIndex = 0;
let lines = [];
let speechRate = 1.0;

document.getElementById("speedSlider").addEventListener("input", (e) => {
  speechRate = parseFloat(e.target.value);
  if (isSpeaking && currentUtterance) {
    speechSynthesis.cancel();
    speakTranslation(); // Herstart met nieuwe snelheid
  }
});

function getBrazilianVoice() {
  const voices = speechSynthesis.getVoices();
  return (
    voices.find(v => v.lang === "pt-BR") ||
    voices.find(v => v.lang.startsWith("pt")) ||
    voices[0]
  );
}

function updateProgress() {
  const bar = document.getElementById("progressBar");
  if (!isSpeaking) {
    bar.style.display = "none";
    return;
  }
  bar.style.display = "block";
  bar.innerText = `Zin ${currentLineIndex + 1} van ${lines.length} (${Math.round(((currentLineIndex + 1) / lines.length) * 100)}%)`;
}

function highlightActiveLine() {
  document.querySelectorAll(".translation-line").forEach(el => {
    el.classList.remove("active-line");
  });
  const active = document.querySelector(`.translation-line[data-index="${currentLineIndex}"]`);
  if (active) active.classList.add("active-line");
}

function speakTranslation() {
  if (isSpeaking) return;

  const article = document.getElementById("article");
  lines = [...article.querySelectorAll(".translation-line:not(.loading)")].map(el => {
    const temp = document.createElement('div');
    temp.innerHTML = el.innerHTML;
    temp.querySelectorAll('strong, .noun').forEach(tag => {
      tag.replaceWith(tag.textContent);
    });
    return temp.textContent.trim();
  }).filter(text => text.length > 0);

  if (lines.length === 0) {
    alert("Geen vertaalde zinnen om voor te lezen");
    return;
  }

  const voice = getBrazilianVoice();
  isSpeaking = true;
  isPaused = false;
  currentLineIndex = 0;

  function speakNext() {
    if (!isSpeaking || currentLineIndex >= lines.length) {
      isSpeaking = false;
      updateProgress();
      highlightActiveLine();
      return;
    }

    highlightActiveLine();
    updateProgress();

    currentUtterance = new SpeechSynthesisUtterance(lines[currentLineIndex]);
    currentUtterance.voice = voice;
    currentUtterance.rate = speechRate;
    currentUtterance.pitch = 1.0;
    currentUtterance.volume = 1.0;

    currentUtterance.onend = () => {
      if (!isPaused) {
        currentLineIndex++;
        setTimeout(speakNext, 300); // Kleine pauze tussen zinnen
      }
    };

    currentUtterance.onerror = (event) => {
      console.error("Spraakfout:", event);
      currentLineIndex++;
      speakNext();
    };

    speechSynthesis.speak(currentUtterance);
  }

  speakNext();
}

function pauseSpeaking() {
  if (!isSpeaking) return;
  if (!isPaused) {
    speechSynthesis.pause();
    isPaused = true;
  } else {
    speechSynthesis.resume();
    isPaused = false;
  }
}

function stopSpeaking() {
  isSpeaking = false;
  isPaused = false;
  speechSynthesis.cancel();
  updateProgress();
  document.querySelectorAll(".translation-line").forEach(el => el.classList.remove("active-line"));
}

function playSingleLine(i) {
  stopSpeaking();
  const voice = getBrazilianVoice();
  const el = document.querySelector(`.translation-line[data-index="${i}"]`);
  if (!el || el.classList.contains('loading')) return;

  document.querySelectorAll(".translation-line").forEach(x => x.classList.remove("active-line"));
  el.classList.add("active-line");

  const temp = document.createElement('div');
  temp.innerHTML = el.innerHTML;
  temp.querySelectorAll('strong, .noun').forEach(tag => {
    tag.replaceWith(tag.textContent);
  });
  const text = temp.textContent.trim();

  if (!text) return;

  const u = new SpeechSynthesisUtterance(text);
  u.voice = voice;
  u.rate = speechRate;
  u.pitch = 1.0;

  u.onend = () => el.classList.remove("active-line");
  u.onerror = () => el.classList.remove("active-line");

  speechSynthesis.speak(u);
}

function prevLine() {
  if (!lines.length) return;
  stopSpeaking();
  currentLineIndex = Math.max(0, currentLineIndex - 1);
  playSingleLine(currentLineIndex);
}

function nextLine() {
  if (!lines.length) return;
  stopSpeaking();
  currentLineIndex = Math.min(lines.length - 1, currentLineIndex + 1);
  playSingleLine(currentLineIndex);
}

/* ========= BATCH VERTALING - GEOPTIMALISEERD ========= */

/* ========= BATCH VERTALING - FIXED VERSION ========= */

async function translateSentencesBatch(sentences, targetLang = "pt-BR") {
  if (sentences.length === 0) return [];
  
  try {
    console.log(`API call voor ${sentences.length} zinnen`);
    
    const url = `/api/translate?sentences=${encodeURIComponent(JSON.stringify(sentences))}&target=${targetLang}`;
    const response = await fetch(url);
    
    if (!response.ok) {
      console.error(`API error ${response.status}`);
      return sentences; // Fallback
    }
    
    const data = await response.json();
    
    // CRITICAL: Zorg dat we altijd een array teruggeven
    if (data && Array.isArray(data.translations)) {
      // Controleer of we Portugese tekst hebben
      const firstTranslation = data.translations[0] || '';
      const hasPortugueseChars = /[áàâãéèêíìîóòôõúùûçñãõ]/i.test(firstTranslation);
      
      console.log(`Ontvangen: ${data.translations.length} vertalingen`);
      console.log(`Portugees detectie: ${hasPortugueseChars ? 'JA' : 'NEE'} (${firstTranslation.substring(0, 50)}...)`);
      
      return data.translations;
    } 
    // Fallback als de API een ander formaat teruggeeft
    else if (data && Array.isArray(data)) {
      console.log('Direct array ontvangen');
      return data;
    }
    else {
      console.warn('Onverwacht response formaat:', data);
      return sentences; // Fallback
    }
  } catch (error) {
    console.error('Vertaling mislukt:', error);
    return sentences; // Fallback
  }
}

function createOptimalBatches(sentences, maxBatchSize = 4) {
  const batches = [];
  let currentBatch = [];
  let currentBatchLength = 0;
  
  for (const sentence of sentences) {
    const sentenceLength = sentence.length;
    
    // Lange zinnen in eigen batch
    if (sentenceLength > 300) {
      if (currentBatch.length > 0) {
        batches.push([...currentBatch]);
        currentBatch = [];
        currentBatchLength = 0;
      }
      batches.push([sentence]);
      continue;
    }
    
    // Batch limieten
    if (currentBatch.length >= maxBatchSize || currentBatchLength + sentenceLength > 1000) {
      if (currentBatch.length > 0) {
        batches.push([...currentBatch]);
      }
      currentBatch = [sentence];
      currentBatchLength = sentenceLength;
    } else {
      currentBatch.push(sentence);
      currentBatchLength += sentenceLength;
    }
  }
  
  if (currentBatch.length > 0) {
    batches.push(currentBatch);
  }
  
  console.log(`[Batch] ${batches.length} batches voor ${sentences.length} zinnen`);
  return batches;
}

async function translateSentencesInParallel(sentences, targetLang = "pt-BR", onProgress) {
  if (sentences.length === 0) return [];
  
  const batches = createOptimalBatches(sentences);
  const allTranslations = new Array(sentences.length).fill("");
  let completedBatches = 0;
  
  // Toon progress
  if (onProgress) onProgress(5, `Start (${batches.length} batches)`);
  
  // Verwerk batches in parallel groepen
  const MAX_CONCURRENT = 3; // 3 batches tegelijk
  let sentenceIndex = 0;
  
  for (let i = 0; i < batches.length; i += MAX_CONCURRENT) {
    const batchGroup = batches.slice(i, i + MAX_CONCURRENT);
    
    // Start alle batches in deze groep
    const batchPromises = batchGroup.map(async (batch, groupIndex) => {
      try {
        const translations = await translateSentencesBatch(batch, targetLang);
        completedBatches++;
        
        // Update progress
        if (onProgress) {
          const progress = 5 + Math.round((completedBatches / batches.length) * 90);
          onProgress(progress, `Batch ${completedBatches}/${batches.length}`);
        }
        
        return { success: true, translations, batchIndex: i + groupIndex };
      } catch (error) {
        console.error(`[Batch ${i + groupIndex}] Fout:`, error);
        return { success: false, translations: batch, batchIndex: i + groupIndex };
      }
    });
    
    // Wacht op deze groep
    const results = await Promise.allSettled(batchPromises);
    
    // Verwerk resultaten
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        const { translations, batchIndex } = result.value;
        const batch = batches[batchIndex];
        
        translations.forEach((translation, transIndex) => {
          if (sentenceIndex < sentences.length) {
            allTranslations[sentenceIndex] = translation || sentences[sentenceIndex];
            sentenceIndex++;
          }
        });
      }
    });
    
    // Tussentijdse update van de weergave (optioneel)
    updatePartialTranslations(allTranslations);
  }
  
  if (onProgress) onProgress(100, "Voltooid");
  return allTranslations;
}

function updatePartialTranslations(translations) {
  // Deze functie kan tussentijdse updates doen als nodig
  console.log(`[Progress] ${translations.filter(t => t && t !== '').length}/${translations.length} vertalingen`);
}

/* ========= PAGINERING FUNCTIES - GEOPTIMALISEERD ========= */

function showLoadingIndicator(progress, message = "") {
  const indicator = document.getElementById("loadingIndicator");
  const progressSpan = document.getElementById("loadingProgress");
  const detailsSpan = document.getElementById("loadingDetails");
  
  if (progress >= 100 || progress <= 0) {
    indicator.style.display = "none";
  } else {
    indicator.style.display = "block";
    progressSpan.textContent = `${progress}%`;
    detailsSpan.textContent = message;
  }
}

function showPerformanceWarning(show) {
  document.getElementById("performanceWarning").style.display = show ? "block" : "none";
}

async function loadTranslationsForPage(pageNumber) {
  if (!currentArticleData || !currentArticleData.sentences) {
    return [];
  }
  
  const startIndex = pageNumber * SENTENCES_PER_PAGE;
  const endIndex = Math.min(startIndex + SENTENCES_PER_PAGE, currentArticleData.sentences.length);
  const pageSentences = currentArticleData.sentences.slice(startIndex, endIndex);
  
  if (pageSentences.length === 0) {
    return [];
  }
  
  console.log(`[Pagina ${pageNumber + 1}] ${pageSentences.length} zinnen vertalen`);
  performanceMetrics.translationStart = Date.now();
  
  // Toon performance info
  showPerformanceWarning(true);
  
  try {
    const translations = await translateSentencesInParallel(
      pageSentences, 
      "pt-BR",
      (progress, message) => {
        showLoadingIndicator(progress, message);
      }
    );
    
    performanceMetrics.translationEnd = Date.now();
    const duration = performanceMetrics.translationEnd - performanceMetrics.translationStart;
    console.log(`[Pagina ${pageNumber + 1}] Vertaald in ${duration}ms`);
    
    showLoadingIndicator(100, `Klaar in ${duration}ms`);
    setTimeout(() => showLoadingIndicator(0), 1000);
    
    return translations;
  } catch (error) {
    console.error(`[Pagina ${pageNumber + 1}] Vertaal fout:`, error);
    showLoadingIndicator(100, "Fout - gebruik originele tekst");
    setTimeout(() => showLoadingIndicator(0), 2000);
    return pageSentences; // Fallback naar origineel
  }
}

function renderPageSkeleton(pageNumber) {
  if (!currentArticleData || !currentArticleData.sentences) return;
  
  const container = document.getElementById("article");
  const sentences = currentArticleData.sentences;
  const title = currentArticleData.title || "";
  const words = currentArticleData.highlightWords || [];
  
  const startIndex = pageNumber * SENTENCES_PER_PAGE;
  const endIndex = Math.min(startIndex + SENTENCES_PER_PAGE, sentences.length);
  const pageSentences = sentences.slice(startIndex, endIndex);
  
  // Bouw HTML skelet (snel)
  let html = `<h2>${applyHighlights(title, words)}</h2>`;
  
  pageSentences.forEach((sentence, index) => {
    const sentenceId = `sentence-${startIndex + index}`;
    html += `
      <div class="translation-group" id="${sentenceId}">
        <span class="translation-original">${applyHighlights(sentence, words)}</span>
        <br>
        <span class="translation-line loading" data-index="${index}" id="trans-${sentenceId}">
          <div class="skeleton-loader" style="width: 80%; height: 16px;"></div>
        </span>
      </div>
    `;
  });
  
  // Paginering controls
  html += `
    <div class="pagination-controls">
      <button class="pagination-btn" onclick="goToPage(${pageNumber - 1})" ${pageNumber === 0 ? 'disabled' : ''}>
        ← Vorige
      </button>
      <span class="pagination-info">
        Pagina ${pageNumber + 1} van ${totalPages}<br>
        <small>Zinnen ${startIndex + 1}-${endIndex} van ${sentences.length}</small>
      </span>
      <button class="pagination-btn" onclick="goToPage(${pageNumber + 1})" ${pageNumber >= totalPages - 1 ? 'disabled' : ''}>
        Volgende →
      </button>
    </div>
  `;
  
  container.innerHTML = html;
  container.style.opacity = 0;
  
  // Animeer verschijning
  requestAnimationFrame(() => {
    container.style.opacity = 1;
  });
  
  currentPage = pageNumber;
  performanceMetrics.pageLoadStart = Date.now();
}

function updatePageWithTranslations(pageNumber, translations) {
  const startIndex = pageNumber * SENTENCES_PER_PAGE;
  const grammarEnabled = document.getElementById("toggleGrammar").checked;
  
  translations.forEach((translation, index) => {
    const globalIndex = startIndex + index;
    const sentenceId = `sentence-${globalIndex}`;
    const translationLine = document.querySelector(`#trans-${sentenceId}`);
    
    if (translationLine) {
      let translationHTML = translation || "";
      
      // Verwijder loading state
      translationLine.classList.remove("loading");
      
      // Pas grammatica aan
      if (grammarEnabled && translationHTML) {
        translationHTML = translationHTML
          .replace(/<span style="color:darkred">/g, '<span class="noun">')
          .replace(/<span style="color: darkred">/g, '<span class="noun">');
      } else if (!grammarEnabled && translationHTML) {
        translationHTML = translationHTML
          .replace(/<strong>/g, '')
          .replace(/<\/strong>/g, '')
          .replace(/<span[^>]*>/g, '')
          .replace(/<\/span>/g, '');
      }
      
      // Update inhoud
      translationLine.innerHTML = translationHTML || "<em>Vertaling niet beschikbaar</em>";
      translationLine.onclick = () => playSingleLine(index);
    }
  });
  
  // Update audio controls
  const translateOn = document.getElementById("toggleTranslate").checked;
  const displayStyle = translateOn ? "flex" : "none";
  document.getElementById("audioControls").style.display = displayStyle;
  document.getElementById("audioNav").style.display = displayStyle;
  document.getElementById("speedControl").style.display = displayStyle;
}

async function goToPage(pageNumber) {
  if (pageNumber < 0 || pageNumber >= totalPages) return;
  
  stopSpeaking();
  showPerformanceWarning(false);
  
  // Snel skelet tonen
  renderPageSkeleton(pageNumber);
  
  const translateOn = document.getElementById("toggleTranslate").checked;
  
  if (translateOn) {
    // Check cache
    const startIndex = pageNumber * SENTENCES_PER_PAGE;
    const endIndex = Math.min(startIndex + SENTENCES_PER_PAGE, currentArticleData.sentences.length);
    
    if (currentArticleData.translations) {
      const cachedSlice = currentArticleData.translations.slice(startIndex, endIndex);
      const hasCachedTranslations = cachedSlice.some(t => t && t !== '');
      
      if (hasCachedTranslations) {
        console.log(`[Cache] Gebruik cached vertalingen voor pagina ${pageNumber + 1}`);
        updatePageWithTranslations(pageNumber, cachedSlice);
        return;
      }
    }
    
    // Laad nieuwe vertalingen
    const translations = await loadTranslationsForPage(pageNumber);
    
    // Cache
    if (!currentArticleData.translations) {
      currentArticleData.translations = new Array(currentArticleData.sentences.length).fill("");
    }
    
    translations.forEach((translation, index) => {
      if (translation && translation !== "") {
        currentArticleData.translations[startIndex + index] = translation;
      }
    });
    
    // Update UI
    updatePageWithTranslations(pageNumber, translations);
  } else {
    // Zonder vertaling
    const startIndex = pageNumber * SENTENCES_PER_PAGE;
    const endIndex = Math.min(startIndex + SENTENCES_PER_PAGE, currentArticleData.sentences.length);
    const emptyTranslations = new Array(endIndex - startIndex).fill("");
    updatePageWithTranslations(pageNumber, emptyTranslations);
  }
}

/* ========= CLOUD SYNC + RSS ========= */

async function fetchCloudData(url) {
  if (!url) return [];
  try {
    const resp = await fetch(url);
    const text = await resp.text();
    return text.split(/[\r\n]+/).map(r => r.replace(/^"|"$/g, "").trim()).filter(r => r);
  } catch {
    return null;
  }
}

async function startSync() {
  const statusEl = document.getElementById("syncStatus");
  statusEl.textContent = "(Syncing...)";

  const wordUrl = localStorage.getItem("syncSheetUrl");
  const feedUrl = localStorage.getItem("syncFeedUrl");

  const [words, feeds] = await Promise.all([
    fetchCloudData(wordUrl),
    fetchCloudData(feedUrl)
  ]);

  if (words) localStorage.setItem("highlightWords", JSON.stringify(words));
  if (feeds) localStorage.setItem("rssFeeds", JSON.stringify(feeds));

  statusEl.textContent = words && feeds ? "(Cloud OK)" : "(Offline)";
}

function applyHighlights(html, words) {
  if (!words || words.length === 0) return html;
  const pattern = [...words]
    .sort((a, b) => b.length - a.length)
    .map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
    .join("|");
  const regex = new RegExp(`\\b(${pattern})\\b(?=[^>]*<)`, "gi");
  return html.replace(regex, m => `<mark class="custom-highlight">${m}</mark>`);
}

function loadSavedFeeds() {
  const select = document.getElementById("feedSelect");
  const feeds = JSON.parse(localStorage.getItem("rssFeeds") || "[]");
  select.innerHTML = feeds.map(f => `<option value="${f}">${f}</option>`).join("");
  if (feeds.length > 0) loadFeed(feeds[0]);
}

async function loadFeed(url) {
  const carousel = document.getElementById("carousel");
  carousel.innerHTML = "Laden...";
  try {
    const resp = await fetch(
      `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(url)}`
    );
    const data = await resp.json();
    items = data.items || [];
    
    carousel.innerHTML = items
      .map((item, idx) => `<div class="slide" data-index="${idx}"><img src="${
        item.thumbnail ||
        (item.enclosure && item.enclosure.link) ||
        "https://via.placeholder.com/150"
      }"></div>`)
      .join("");
    
    setTimeout(() => {
      if (carousel.scrollLeft === 0) {
        loadArticle(0);
      }
    }, 100);
    
  } catch {
    carousel.innerHTML = "Fout bij laden feed.";
  }
}

function loadSelectedFeed() {
  loadFeed(document.getElementById("feedSelect").value);
}

async function loadArticle(index) {
  stopSpeaking();
  currentPage = 0;
  showLoadingIndicator(10, "Artikel laden...");

  const container = document.getElementById("article");
  container.style.opacity = 0;
  container.innerHTML = "Artikel laden...";
  currentIndex = index;

  try {
    const link = items[index]?.link;
    if (!link) return;

    showLoadingIndicator(30, "Inhoud ophalen...");
    
    const resp = await fetch(`/api/article?url=${encodeURIComponent(link)}`);
    const data = await resp.json();
    const words = JSON.parse(localStorage.getItem("highlightWords") || "[]");

    const html = data.content;
    const title = data.title || "";

    showLoadingIndicator(60, "Zinnen extraheren...");
    
    // Zinnen extraheren
    const temp = document.createElement("div");
    temp.innerHTML = html;
    const text = temp.textContent || temp.innerText || "";
    
    const sentences = splitIntoSentences(text);
    
    totalPages = Math.ceil(sentences.length / SENTENCES_PER_PAGE);
    
    currentArticleData = {
      title: title,
      sentences: sentences,
      highlightWords: words,
      translations: null // Lazy initialization
    };

    showLoadingIndicator(80, "Pagina voorbereiden...");
    
    await goToPage(0);
    
    showLoadingIndicator(100, "Klaar");
    setTimeout(() => showLoadingIndicator(0), 500);
    
  } catch (error) {
    console.error("Artikel laad fout:", error);
    container.innerHTML = "Fout bij laden van artikel.";
    showLoadingIndicator(100, "Fout");
    setTimeout(() => showLoadingIndicator(0), 2000);
  }
}

/* ========= SWIPE ========= */

let carouselScrollTimeout;

document.getElementById("carousel").onscroll = () => {
  clearTimeout(carouselScrollTimeout);
  carouselScrollTimeout = setTimeout(() => {
    const slide = document.querySelector(".slide");
    if (!slide) return;
    const slideWidth = slide.offsetWidth + 10;
    const index = Math.round(document.getElementById("carousel").scrollLeft / slideWidth);
    if (index !== currentIndex && items[index]) {
      loadArticle(index);
    }
  }, 50);
};

document.getElementById("carousel").addEventListener("click", (e) => {
  const slide = e.target.closest(".slide");
  if (slide) {
    const index = parseInt(slide.dataset.index);
    if (!isNaN(index) && index !== currentIndex && items[index]) {
      slide.scrollIntoView({ behavior: 'smooth', inline: 'center' });
      loadArticle(index);
    }
  }
});

/* ========= TOGGLE EVENT LISTENERS ========= */

document.getElementById("toggleGrammar").addEventListener("change", function() {
  if (currentArticleData && currentArticleData.sentences) {
    // Herlaad huidige pagina met nieuwe grammatica-instelling
    const startIndex = currentPage * SENTENCES_PER_PAGE;
    const endIndex = Math.min(startIndex + SENTENCES_PER_PAGE, currentArticleData.sentences.length);
    
    if (currentArticleData.translations) {
      const translations = currentArticleData.translations.slice(startIndex, endIndex);
      updatePageWithTranslations(currentPage, translations);
    }
  }
});

document.getElementById("toggleTranslate").addEventListener("change", function() {
  const translateOn = this.checked;
  
  // Update controls
  const displayStyle = translateOn ? "flex" : "none";
  document.getElementById("audioControls").style.display = displayStyle;
  document.getElementById("audioNav").style.display = displayStyle;
  document.getElementById("speedControl").style.display = displayStyle;
  
  if (currentArticleData && currentArticleData.sentences) {
    if (translateOn) {
      // Laad vertalingen voor huidige pagina
      goToPage(currentPage);
    } else {
      // Toon zonder vertalingen
      const startIndex = currentPage * SENTENCES_PER_PAGE;
      const endIndex = Math.min(startIndex + SENTENCES_PER_PAGE, currentArticleData.sentences.length);
      const emptyTranslations = new Array(endIndex - startIndex).fill("");
      updatePageWithTranslations(currentPage, emptyTranslations);
    }
  }
});

/* ========= INIT ========= */

async function init() {
  console.log("Reader initialiseren...");
  await startSync();
  loadSavedFeeds();

  if (typeof speechSynthesis !== "undefined") {
    speechSynthesis.onvoiceschanged = () => {
      console.log("Spraakstemmen geladen:", speechSynthesis.getVoices().length);
    };
  }
  
  // Performance tip tonen
  showPerformanceWarning(true);
  setTimeout(() => showPerformanceWarning(false), 5000);
}

// Helper voor sentence splitting
function splitIntoSentences(text) {
  return text
    .replace(/\s+/g, " ")
    .trim()
    .split(/(?<![A-Z][a-z]\.)(?<![A-Z][a-z][a-z]\.)(?<![Mm]r\.)(?<![Mm]rs\.)(?<![Dd]r\.)(?<![Pp]rof\.)(?<![Ss]r\.)(?<![Jj]r\.)(?<![Vv]s\.)(?<![Ee]tc\.)(?<![Ee]g\.)(?<![Ii]e\.)(?<=[.!?])\s+/)
    .filter(s => s.trim().length > 0);
}

// Debug functies
window.debugPerformance = function() {
  console.log("=== PERFORMANCE METRICS ===");
  console.log("Artikelen geladen:", items.length);
  if (currentArticleData) {
    console.log("Huidig artikel zinnen:", currentArticleData.sentences.length);
    console.log("Pagina's:", totalPages);
    console.log("Gecachte vertalingen:", 
      currentArticleData.translations ? 
      currentArticleData.translations.filter(t => t && t !== '').length : 0);
  }
  console.log("SpeechSynthesis beschikbaar:", typeof speechSynthesis !== "undefined");
  console.log("==========================");
};

init();

</script>
</body>
</html>
